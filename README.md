# AlgorithmJava

这个代码仓库仅用于本人学习算法知识所用。更新顺序与《小灰的算法之旅》相同。

[TOC]

## 数据结构

### 数组

#### 插入

数组的插入分为：

- 头部插入

  顾名思义，也就是在数组的最前面插入数据，每次插入的位置都是数组下标为 0 的位置；

- 中间插入

  中间插入，就是在数组中任意一个下标进行插入，插入时，待插入位置及其右边(后面)的数据依次向右移动一位，为新数据的插入提供位置；

- 尾部插入

  尾部插入就是每次插入均位于数组的最后位置；

但无论通过什么形式的插入，都需要在数组插入数据时，对数组长度进行判断，判断其是否需要扩容，如需要扩容则创建一个长度为原数组长度 n 倍的数组，并将其复制，最后再把新数组赋值给旧数组即可。

##### 时间复杂度

数组插入的时间复杂度可分为扩容及实际插入两个部分，扩容的复杂度为 n，实际插入的复杂度为 n，综合起来，为 2n，去除最高项系数，则数组插入的时间复杂度为 n。

#### 删除

删除元素与插入正好相反，将待删除元素右侧(后面)的数据依次向左(前)移动一位即可。

#### 小结

数组有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对于的元素「时间复杂度为 1」。但是在插入及删除元素方面就显得不那么便捷，由于数组元素紧密的存储在内存中，所以插入、删除元素都会导致大量元素被迫移动，影响效率。

### 链表

链表分为：

- 单向链表
- 双向链表

#### 插入

- 头部插入

  头部插入在 size 为 0 时进行，插入的节点既是 head 同时也是 last；

- 中部插入

  中部插入时，需要将下一节点设置为当前的 next，并把前一个节点的 next 设为当前节点；

- 尾部插入

  尾部插入时，下标为 size - 1，插入后需要设置前一节点的 next 为当前节点，且当前节点为 last；

#### 删除

与插入正好相反，在删除操作时，将其 next 关系解除即可。Java 这类高级语言具有自动垃圾回收机制。

#### 时间复杂度

在不考虑遍历元素的情况下，链表的插入及删除的时间复杂度均为 1。

#### 小结

由于链表在存储过程中使用随机存储的方式进行存储，所以，在插入时，不需要考虑链表的扩容行为，因为每一节点已经包含了下一节点。同样的，依赖于随机存储的特性，在删除节点时，不需要像数组对剩余数据的搬运，仅需要处理当前节点 next 节点即可。

### 栈&队列

#### 栈

先入后出(FIFO)

##### 基本操作：

- 入栈
- 出栈

##### 时间复杂度

入栈、出栈均为 1。

#### 队列

先入先出(FIFO)

##### 基本操作

- 入队
- 出队

##### 时间复杂度

入队、出队均为 1。

#### 循环队列

当一个队列为满队列后再清空队列，此时再次入队，如果使用数组进行实现的队列，则会出现数组元素为空，但没有剩余空间分配给队列，此时可以考虑使用**循环队列**的方法。循环队列，就是利用了已经出队列的元素留下的空间，让队尾指针重新回到数组的首位。

#### 小结

栈的输出顺序与输入顺序相反，所以栈通常用于对历史的回溯，也就是逆流而上追溯历史。Android 上页面之间的导航也相当于是 Activity 的调用栈。类似的还有 Fragment 调用栈，方法调用栈等等。

队列的输出顺序与输入顺序相同，所以队列通常用于对历史的回放，也就是重演一遍历史。比如 Android 中 MessageQueue 队列，以及多线程中，不同线程对资源索取的等待队列。

### 散列表(哈希表)

散列表也叫作哈希表，这种数据结构提供了键（Key）和值（Value）的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于1。哈希表的本质上也是一个数组。

主要把 key 转换成数组的下标，具体转换的实际算法，可能是 `HashCode( Key ) % Array.length`。

#### 基本操作

- 写 put

  「有限数组空间内」在写入时，由于使用 HashCode( key ) 的方法，是有可能造成 Hash 冲突的，主要有两个解决方案：

  1. 开放寻址法，当一个 key 通过哈希函数获得对于数组下标已被占用时，继续寻址即可。继续寻址可能意味着新的下标可能为：` HashCode( key ) + 1`

   	2. 链表法：哈希数组的每一个元素都是一个链表的头节点，当发生 Hash 冲突时，新来的哈希元素都会插入到对应的链表中。

- 读 put

  与写操作类似，不同的是，从 Hash 数组中读数据，得益于数组的优越性，所以读操作的时间复复杂度接近于 1。

- 扩容 resize

  经过多次元素的插入，Hash 表达到一定饱和度 Hash 冲突的概率会逐步提高，如此一来，大量元素拥挤在相同的数组下标位置，导致形成很长的链表，对后续的插入及查询的性能都有很大影响。而且 Hash 表的扩容也不像数组扩容那样简单，Hash 表扩容需要：1. 扩容；2. 利用 Hash 重新分配下标；

### 树&二叉树

#### 树

树（Tree）是 n（n>=0）个节点的有限集。当 n = 0 时，称为空树。在任意一个非空树中，有如下特点。

1. 有且仅有一个特定的称为根的节点。
2. 当 n>1时，其余节点可分为 m（m>0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。

#### 二叉树

二叉树是树的一种特殊形式。二叉树的每个节点**最多有 2 个孩子节点**。一个称为左孩子（left child），一个叫右孩子（right child）。

##### 满二叉树

一个二叉树的所有非叶子节点都存在左右孩子，且所有叶子节点都在同一个层级上，那么这个数就是满二叉树。

##### 完全二叉树

对于一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n。如果这个数所有节点和同样深度的满二叉树的编号从 1到 n 的节点位置相同，则这个二叉树为完全二叉树。

#### 实现方式

- 链式存储

  使用链表的形式，每一节点（Node）均包含左右节点的引用及实际值。

- 数组

  所有节点当做数组的元素，假设父节点的下标为 parent，那么左孩子节点下标为 `2*parent+1`，右孩子节点下标为 `2*parent +2` 。反过来，左孩子节点的下标是 leftChild，那么父节点就是 `(leftChild-1)/2`，如果右孩子节点的下标是 rightChild，那么父节点就是 `(rightChild-2)/2`。

#### 遍历

从遍历过程中节点之间位置关系的角度看，二叉树的遍历分为：

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历

而从更宏观的角度看，又可以分为两个大类

> 图片节点左侧数字为输出顺序

- 深度优先遍历

  1. 前序遍历

     输出顺序为：根节点、左子树、右子树

     ![](https://i.loli.net/2019/10/15/g67Ux9K8tySprkb.png)

  2. 中序遍历

     输出顺序：左子树、根节点、右子树

     ![](https://i.loli.net/2019/10/15/BI1ituGsAl5eYMD.png)

  3. 后序遍历

     输出顺序：左子树、右子树、根节点

     ![](https://i.loli.net/2019/10/15/k3PruCBW4L5mSpT.png)

- 广度优先遍历

  1. 层序遍历
  
     输出顺序：根节点到叶子节点的层级关系。
  
     ![](https://i.loli.net/2019/10/15/rt6W75Qn2Vvxuma.png)

#### 二叉堆

二叉堆本质上是一种完全二叉树，主要分为**最大堆**与**最小堆**。最大堆的任何一个父节点的值都大于或等于它左、右子节点的值；最小值的任何一个父节点的值都小于或等于左、右子节点的值。二叉堆的根节点叫做堆顶。虽然二叉堆是一个完全二叉树，但他的存储方式并不是链式存储 ，而是顺序存储，**二叉堆的所有节点都存储在数组中。**

##### 基本操作

> Note: 以下讨论的是最小二叉堆，即堆顶为最小值。

- 插入

  插入新节点是，插入位置是完全二叉树的最后一个位置。插入后需要主动进行「上浮」操作，目的是构建为最大堆或是最小堆。

  时间复杂度：logn

- 删除

  每次删除新的节点均为堆顶的节点，然后让最后一个节点临时补到原本堆顶的位置，再依次下沉。

  时间复杂度：logn

- 构建

  构建二叉堆就是把一个无序的完全二叉树调整为二叉堆。让所有非叶子节点依次「下沉」。

  时间复杂度：n

##### 优先队列

优先队列是在队列及二叉堆的基础上一种实现，分为最大优先队列和最小优先队列。在优先队列中，无论入队顺序，最值都会优先出队。根据二叉堆的原理，所以优先队列的入队及出队的时间复杂度等同于二叉堆的插入及删除的时间复杂度等于 logn。

## 排序算法

主流的排序算法可分为 3 大类：

1. 时间复杂度为 N^2^ 的排序算法：
   - 冒泡排序
   - 选择排序
   - 插入排序
   - 希尔排序（性能略逊于 N^2^，但又比不上 nlog n）
2. 时间复杂度为 nlog n 的排序算：
   - 快速排序
   - 归并排序
   - 堆排序
3. 时间复杂度为线性的排序算法：
   - 计数排序
   - 桶排序
   - 基数排序

还可以根据是否更换相同元素的位置来分为稳定排序和不稳定排序，某些特殊场景下不能更改元数据中相同数据元素的位置。

![](https://i.loli.net/2019/10/22/nVFARm82j3bNzr1.png)

### 冒泡排序

把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换他们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。

![](https://i.loli.net/2019/10/22/a3Oc25E8wIWZSR6.png)

冒泡排序可进行优化：

1. 可以设计一个标志位，当某一轮出现未排序的情况，意味着当前顺序是有序的即为可以跳出循环；
2. 通过设置有序区边界控制循环次数；

鸡尾酒排序就是基于一种基于冒泡排序的升级版。

